
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>x.hh.ru: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">x.hh.ru/Main.go (11.1%)</option>
				
				<option value="file1">x.hh.ru/cfg.go (96.8%)</option>
				
				<option value="file2">x.hh.ru/crypting.go (83.3%)</option>
				
				<option value="file3">x.hh.ru/firstEncrypt.go (0.0%)</option>
				
				<option value="file4">x.hh.ru/parseHHru.go (73.7%)</option>
				
				<option value="file5">x.hh.ru/telegram.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
        "sync"
)

const (
        password = "qZ}~zo~f)7rUy&lt;4)\"?/r?OB4№7iKl)Xpo?ypx!M&gt;kls,}xIjF}"
        cfgFile  = "config.cfg"
)

var (
        token               = ""
        loginHHru           = ""
        passwordHHru        = ""
        passwordTeleBot     = ""
        resumeForUpdates    []string
        timeoutResumeUpdate = 0
        lock                = &amp;sync.Mutex{}
)

func checkErr(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(2)
        }</span>
}

func main() <span class="cov0" title="0">{
        parseCfg()
        wg := sync.WaitGroup{}
        wg.Add(1)
        go startBot()
        go goUpdateMonitor(false)
        wg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "strconv"
        "strings"
)

func parseCfg() <span class="cov8" title="1">{
        decryptByte := decryptFile(cfgFile, password)
        decryptText := string(decryptByte)
        decryptStrArr := strings.Split(decryptText, "\n")
        for _, v := range decryptStrArr </span><span class="cov8" title="1">{
                str := strings.Split(v, "&amp;&amp;||")
                param := strings.ToLower(str[0])
                if param == "token" </span><span class="cov8" title="1">{
                        token = str[1]
                }</span> else<span class="cov8" title="1"> if param == "loginhhru" </span><span class="cov8" title="1">{
                        loginHHru = str[1]
                }</span> else<span class="cov8" title="1"> if param == "passwordhhru" </span><span class="cov8" title="1">{
                        passwordHHru = str[1]
                }</span> else<span class="cov8" title="1"> if param == "passwordtelebot" </span><span class="cov8" title="1">{
                        passwordTeleBot = str[1]
                }</span> else<span class="cov8" title="1"> if param == "resumeforupdates" </span><span class="cov8" title="1">{
                        str := strings.Split(str[1], "|")
                        for _, v := range str </span><span class="cov8" title="1">{
                                if v != "" </span><span class="cov8" title="1">{
                                        resumeForUpdates = append(resumeForUpdates, v)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if param == "timeoutresumeupdates" </span><span class="cov8" title="1">{
                        var err error
                        timeoutResumeUpdate, err = strconv.Atoi(str[1])
                        checkErr(err)
                        println(timeoutResumeUpdate)
                }</span>
        }
}

func saveCfg() <span class="cov8" title="1">{
        resumeStr := ""
        for i, v := range resumeForUpdates </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        resumeStr = v + "|"
                }</span> else<span class="cov0" title="0"> {
                        resumeStr += v + "|"
                }</span>
        }
        <span class="cov8" title="1">outCfg := "Token&amp;&amp;||" + token + "\nloginHHru&amp;&amp;||" + loginHHru + "\npasswordHHru&amp;&amp;||" + passwordHHru +
                "\npasswordTeleBot&amp;&amp;||" + passwordTeleBot + "\nresumeForUpdates&amp;&amp;||" + resumeStr + "\ntimeoutResumeUpdates&amp;&amp;||" + strconv.Itoa(timeoutResumeUpdate)
        // _ = outCfg
        encryptFile(cfgFile, []byte(outCfg), password)</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/md5"
        "crypto/rand"
        "encoding/hex"
        "io"
        "io/ioutil"
        "os"
)

func createHash(key string) string <span class="cov8" title="1">{
        hasher := md5.New()
        hasher.Write([]byte(key))
        return hex.EncodeToString(hasher.Sum(nil))
}</span>

func encrypt(data []byte, passphrase string) []byte <span class="cov8" title="1">{
        block, _ := aes.NewCipher([]byte(createHash(passphrase)))
        gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, data, nil)
        return ciphertext</span>
}

func decrypt(data []byte, passphrase string) []byte <span class="cov8" title="1">{
        key := []byte(createHash(passphrase))
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov8" title="1">return plaintext</span>
}

func encryptFile(filename string, data []byte, passphrase string) <span class="cov8" title="1">{
        f, _ := os.Create(filename)
        defer f.Close()
        f.Write(encrypt(data, passphrase))
}</span>

func decryptFile(filename string, passphrase string) []byte <span class="cov8" title="1">{
        data, _ := ioutil.ReadFile(filename)
        return decrypt(data, passphrase)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "io/ioutil"
)

func firstEncryptCfg() <span class="cov0" title="0">{
        text, err := ioutil.ReadFile("cfg")
        if err != nil </span><span class="cov0" title="0">{
                panic("aaaaa")</span>
        }
        <span class="cov0" title="0">fmt.Println(string(text))
        encryptFile(cfgFile, text, password)</span>
}

// func main() {
//         firstEncryptCfg()
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"
        "os/user"
        "strconv"
        "strings"
        "time"

        "github.com/chromedp/cdproto/cdp"
        "github.com/chromedp/chromedp"
)

//Получить домашнюю директорию пользователя
func getUsrHomeDir() string <span class="cov8" title="1">{
        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
        <span class="cov8" title="1">return usr.HomeDir</span>
}

//Подготовить контекст для запуска браузера
func prepareChrome(visibleBrowser bool) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        var ctx context.Context
        var cancel context.CancelFunc
        // userDir := `C:\Users\user`
        userDir := getUsrHomeDir()
        if visibleBrowser </span><span class="cov8" title="1">{
                opts := append(chromedp.DefaultExecAllocatorOptions[:],
                        // chromedp.DisableGPU,
                        chromedp.Flag("start-maximized", true),
                        chromedp.Flag("headless", false),
                        chromedp.Flag("no-first-run", true),
                        chromedp.Flag("no-sandbox", true),
                        chromedp.Flag("disable-gpu", true),
                        chromedp.Flag("enable-automation", true),
                        chromedp.Flag("restore-on-startup", false),
                        chromedp.UserDataDir(userDir),
                )
                ctx, cancel = chromedp.NewExecAllocator(context.Background(), opts...)
                // defer cancel()
                ctx, cancel = chromedp.NewContext(ctx)
                // defer cancel()
        }</span> else<span class="cov8" title="1"> {
                opts := append(chromedp.DefaultExecAllocatorOptions[:],
                        // chromedp.DisableGPU,
                        chromedp.Flag("headless", false),
                        chromedp.Flag("no-first-run", true),
                        chromedp.Flag("no-sandbox", true),
                        chromedp.Flag("disable-gpu", true),
                        chromedp.Flag("enable-automation", true),
                        chromedp.Flag("restore-on-startup", true),
                        chromedp.UserDataDir(userDir),
                        // chromedp.WindowSize(10, 10),
                        // chromedp.Flag("minimal", true),
                        chromedp.Flag("window-position", "-1000,-1000"),
                )
                ctx, cancel = chromedp.NewExecAllocator(context.Background(), opts...)
                ctx, cancel = chromedp.NewContext(ctx)

                // defer cancel()
                _ = ctx
        }</span>
        <span class="cov8" title="1">return ctx, cancel</span>
}

//При первом запуске необходимо авторизоваться вручную
func firstRunChrome(ctx context.Context, cancel context.CancelFunc) <span class="cov8" title="1">{
        chromedp.Run(ctx,
                chromedp.Navigate("https://togliatti.hh.ru/account/login?backurl=%2F"),
                chromedp.WaitVisible(`/html/body/div[4]/div[1]/div/div/div[1]/div[1]/a`),
        )
        cancel()
}</span>

//Получить список резюме
func getResumeList(ctx context.Context, cancel context.CancelFunc) (result []string) <span class="cov8" title="1">{
        if ctx.Err()!=nil</span><span class="cov0" title="0">{
                fmt.Println(ctx.Err())
                return
        }</span>
        <span class="cov8" title="1">defer cancel()
        ctx, cancel = context.WithTimeout(ctx, 25*time.Second)
        defer cancel()
        var nodes, children []*cdp.Node
        var resume, status string

        err := chromedp.Run(
                ctx,
                chromedp.Navigate("https://togliatti.hh.ru/applicant/resumes?from=header_new"),
                chromedp.Nodes(`div.bloko-column.bloko-column_xs-4.bloko-column_s-8.bloko-column_m-8.bloko-column_l-11`,
                        &amp;nodes),
        )

        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov8" title="1">err = chromedp.Run(
                ctx,
                chromedp.Nodes("div.bloko-gap.bloko-gap_top.bloko-gap_bottom",
                        &amp;children, chromedp.ByQueryAll, chromedp.FromNode(nodes[0])),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov8" title="1">for _, n := range children </span><span class="cov8" title="1">{
                chromedp.Run(
                        ctx,
                        chromedp.Text("div&gt;h3&gt;a&gt;span", &amp;resume, chromedp.ByQueryAll, chromedp.FromNode(n)),
                        chromedp.Text("div&gt;div.applicant-resumes-status",
                                &amp;status, chromedp.ByQueryAll, chromedp.FromNode(n)),
                )
                if strings.ToLower(status) != "не видно никому" </span><span class="cov8" title="1">{
                        result = append(result, resume)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

//Монитор обновлния резюме
func goUpdateMonitor(visibleBrowser bool) <span class="cov8" title="1">{
        timeout := 0
        timeUntilUpdate := 0
        for </span><span class="cov8" title="1">{
                if timeout != timeoutResumeUpdate </span><span class="cov8" title="1">{
                        lock.Lock()
                        timeout = timeoutResumeUpdate
                        timeUntilUpdate = 0
                        lock.Unlock()
                }</span>
                <span class="cov8" title="1">time.Sleep(1 * time.Second)
                timeUntilUpdate++
                lock.Lock()
                tmp := timeoutResumeUpdate
                lock.Unlock()
                if timeUntilUpdate &gt;= (tmp * 60) </span><span class="cov0" title="0">{
                        var ctx context.Context
                        var cancel context.CancelFunc
                        if visibleBrowser </span><span class="cov0" title="0">{
                                ctx, cancel = prepareChrome(true)
                        }</span> else<span class="cov0" title="0"> {
                                ctx, cancel = prepareChrome(false)
                        }</span>
                        <span class="cov0" title="0">for _, v := range resumeForUpdates </span><span class="cov0" title="0">{
                                updateResume(ctx, v)
                        }</span>
                        <span class="cov0" title="0">cancel()
                        timeUntilUpdate = 0</span>
                }
        }
}

func updateResume(ctx context.Context, resume string) <span class="cov8" title="1">{
        var nodes, children []*cdp.Node
        ctx, _ = context.WithTimeout(ctx, 25*time.Second)
        err := chromedp.Run(
                ctx,
                chromedp.Navigate("https://togliatti.hh.ru/applicant/resumes?from=header_new"),
                chromedp.Nodes(`div.bloko-column.bloko-column_xs-4.bloko-column_s-8.bloko-column_m-8.bloko-column_l-11`,
                        &amp;nodes),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov8" title="1">err = chromedp.Run(
                ctx,
                chromedp.Nodes("div.bloko-gap.bloko-gap_top.bloko-gap_bottom",
                        &amp;children, chromedp.ByQueryAll, chromedp.FromNode(nodes[0])),
        )
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov8" title="1">for i, n := range children </span><span class="cov8" title="1">{
                resumeInt, _ := strconv.Atoi(resume)
                if (i + 1) == resumeInt </span><span class="cov8" title="1">{
                        chromedp.Run(
                                ctx,
                                chromedp.Click("div&gt;div.bloko-gap.bloko-gap_top&gt;div&gt;div&gt;div&gt;div:nth-child(1)&gt;span&gt;button", chromedp.ByQueryAll, chromedp.FromNode(n)),
                        )
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        // "fmt"
        "strconv"
        "strings"
        "time"

        tb "gopkg.in/tucnak/telebot.v2"
)

const (
        teleAdminID = 385060683
)

func helpAndStart(m *tb.Message, bot *tb.Bot) <span class="cov0" title="0">{
        if m.Sender.ID == teleAdminID </span><span class="cov0" title="0">{
                msg := `loginHHru=&lt;Задать логин от сайта hh.ru&gt;

passwordHHru=&lt;Задать пароль от сайта hh.ru&gt;

timeoutResumeUpdate=&lt;Установить частоту обновления резюме (в минутах)&gt;

setResume=&lt;Сохранить выбранные резюме для обновления (перечислить номера резюме (результат команды getResume) через запятую)&gt;

startUpdate=&lt;(true, false)  принудительно запустить обновление резюме в видимом или не видимом режиме&gt;

startAuthentication Запустить браузер для авторизации

getResume Получить список резюме

getLoginHHru Получить логин на hh.ru

getTimeoutResumeUpdate Получить тайм-аут`
                bot.Send(m.Sender, msg)
        }</span>
}

func startBot() <span class="cov0" title="0">{
        chromeIsRunning := false
        bot, err := tb.NewBot(tb.Settings{Token: token, Poller: &amp;tb.LongPoller{Timeout: 10 * time.Second}})
        checkErr(err)
        teleAdminUser := tb.User{ID: teleAdminID}
        bot.Handle("/help", func(m *tb.Message) </span><span class="cov0" title="0">{
                helpAndStart(m, bot)
        }</span>)
        <span class="cov0" title="0">bot.Handle("/start", func(m *tb.Message) </span><span class="cov0" title="0">{
                helpAndStart(m, bot)
        }</span>)

        <span class="cov0" title="0">bot.Handle(tb.OnText, func(m *tb.Message) </span><span class="cov0" title="0">{
                if m.Sender.ID == teleAdminID </span><span class="cov0" title="0">{
                        if strings.HasPrefix(strings.ToLower(m.Text), "startupdate") </span><span class="cov0" title="0">{
                                text := strings.Split(m.Text, "=")[1]
                                if !chromeIsRunning </span><span class="cov0" title="0">{
                                        chromeIsRunning = true
                                        if strings.ToLower(strings.TrimSpace(text)) == "false" </span><span class="cov0" title="0">{
                                                bot.Send(m.Sender, "Обновляем...")
                                                ctx, cancel := prepareChrome(false)
                                                for _, resume := range resumeForUpdates </span><span class="cov0" title="0">{
                                                        updateResume(ctx, resume)
                                                }</span>
                                                <span class="cov0" title="0">cancel()
                                                bot.Send(m.Sender, "Готово")</span>
                                        } else<span class="cov0" title="0"> if strings.ToLower(strings.TrimSpace(text)) == "true" </span><span class="cov0" title="0">{
                                                bot.Send(m.Sender, "Обновляем...")
                                                ctx, cancel := prepareChrome(true)
                                                for _, resume := range resumeForUpdates </span><span class="cov0" title="0">{
                                                        updateResume(ctx, resume)
                                                }</span>
                                                <span class="cov0" title="0">cancel()
                                                bot.Send(m.Sender, "Готово")</span>
                                        } else<span class="cov0" title="0"> {
                                                bot.Send(m.Sender, "Не верная команда")
                                        }</span>
                                        <span class="cov0" title="0">chromeIsRunning = false</span>
                                } else<span class="cov0" title="0"> {
                                        bot.Send(m.Sender, "Процедура уже запущена")
                                }</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "startauthentication") </span><span class="cov0" title="0">{
                                if !chromeIsRunning </span><span class="cov0" title="0">{
                                        chromeIsRunning = true
                                        ctx, cancel := prepareChrome(true)
                                        firstRunChrome(ctx, cancel)
                                        chromeIsRunning = false
                                }</span> else<span class="cov0" title="0"> {
                                        bot.Send(m.Sender, "Процедура уже запущена")
                                }</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "loginhhru") </span><span class="cov0" title="0">{
                                saveLoginHHru(m, bot)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "passwordhhru") </span><span class="cov0" title="0">{
                                savePasswordHHru(m, bot)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "timeoutresumeupdate") </span><span class="cov0" title="0">{
                                saveTimeoutResumeUpdate(m, bot)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "setresume") </span><span class="cov0" title="0">{
                                saveResume(m, bot)
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "getresume") </span><span class="cov0" title="0">{
                                if !chromeIsRunning </span><span class="cov0" title="0">{
                                        chromeIsRunning = true
                                        bot.Send(m.Sender, "Получаем данные, ожидайте...")
                                        ctx, cancel := prepareChrome(false)
                                        resumeList := getResumeList(ctx, cancel)
                                        msg := ""
                                        for i, resume := range resumeList </span><span class="cov0" title="0">{
                                                msg += msg + strconv.Itoa(i+1) + " - " + resume + "\n"
                                        }</span>
                                        <span class="cov0" title="0">bot.Send(m.Sender, msg)
                                        chromeIsRunning = false</span>
                                } else<span class="cov0" title="0"> {
                                        bot.Send(m.Sender, "Процедура уже запущена")
                                }</span>
                        } else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "getloginhhru") </span><span class="cov0" title="0">{
                                lock.Lock()
                                bot.Send(m.Sender, loginHHru)
                                lock.Unlock()
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(strings.ToLower(m.Text), "gettimeoutresumeupdate") </span><span class="cov0" title="0">{
                                lock.Lock()
                                bot.Send(m.Sender, strconv.Itoa(timeoutResumeUpdate))
                                lock.Unlock()
                        }</span> else<span class="cov0" title="0"> {
                                bot.Send(m.Sender, "Не верная команда")
                        }</span>
                }
        })
        <span class="cov0" title="0">bot.Send(&amp;teleAdminUser, "Запуск - "+time.Now().Format(time.ANSIC))
        bot.Start()</span>
}

func saveResume(m *tb.Message, bot *tb.Bot) <span class="cov0" title="0">{
        text := strings.Split(m.Text, "=")
        if len(text) == 2 </span><span class="cov0" title="0">{
                lock.Lock()
                if len(strings.TrimSpace(text[1])) &gt; 0 </span><span class="cov0" title="0">{
                        resumeTmpList := strings.Split(strings.TrimSpace(text[1]), ",")
                        for _, v := range resumeTmpList </span><span class="cov0" title="0">{
                                var err error
                                _, err = strconv.Atoi(v)
                                if err != nil </span><span class="cov0" title="0">{
                                        bot.Send(m.Sender, "Минимум в одном из параметров не числовое значение")
                                        lock.Unlock()
                                        return
                                }</span>
                        }
                        <span class="cov0" title="0">resumeForUpdates = []string{}
                        for _, v := range resumeTmpList </span><span class="cov0" title="0">{
                                resumeForUpdates = append(resumeForUpdates, strings.TrimSpace(v))
                        }</span>
                        <span class="cov0" title="0">saveCfg()
                        lock.Unlock()
                        bot.Send(m.Sender, "Список резюме успешно сохранён")
                        return</span>
                } else<span class="cov0" title="0"> {
                        bot.Send(m.Sender, "Не задано не одного значения")
                        lock.Unlock()
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                bot.Send(m.Sender, "Не верная команда")
        }</span>
}

func saveTimeoutResumeUpdate(m *tb.Message, bot *tb.Bot) <span class="cov0" title="0">{
        text := strings.Split(m.Text, "=")
        if len(text) == 2 </span><span class="cov0" title="0">{
                lock.Lock()
                var err error
                timeoutResumeUpdate, err = strconv.Atoi(strings.TrimSpace(text[1]))
                if err != nil </span><span class="cov0" title="0">{
                        bot.Send(m.Sender, "Ожидается число")
                        lock.Unlock()
                        return
                }</span>
                <span class="cov0" title="0">saveCfg()
                lock.Unlock()
                bot.Send(m.Sender, "Тайм-аут успешно сохранён")</span>
        } else<span class="cov0" title="0"> {
                bot.Send(m.Sender, "Не верная команда")
        }</span>
}

func saveLoginHHru(m *tb.Message, bot *tb.Bot) <span class="cov0" title="0">{
        text := strings.Split(m.Text, "=")
        if len(text) == 2 </span><span class="cov0" title="0">{
                lock.Lock()
                loginHHru = strings.TrimSpace(text[1])
                saveCfg()
                lock.Unlock()
                bot.Send(m.Sender, "Логин успешно сохранён")
        }</span> else<span class="cov0" title="0"> {
                bot.Send(m.Sender, "Не верная команда")
        }</span>
}

func savePasswordHHru(m *tb.Message, bot *tb.Bot) <span class="cov0" title="0">{
        text := strings.Split(m.Text, "=")
        if len(text) == 2 </span><span class="cov0" title="0">{
                lock.Lock()
                passwordHHru = strings.TrimSpace(text[1])
                saveCfg()
                lock.Unlock()
                bot.Send(m.Sender, "Пароль успешно сохранён")
        }</span> else<span class="cov0" title="0"> {
                bot.Send(m.Sender, "Не верная команда")
        }</span>
}

// func tst() {
//         b, err := tb.NewBot(tb.Settings{Token: token, Poller: &amp;tb.LongPoller{Timeout: 10 * time.Second}})
//         checkErr(err)
//         teleAdminUser := tb.User{ID: teleAdminID}
//         // var (
//         //         menu    = &amp;tb.ReplyMarkup{ResizeReplyKeyboard: true}
//         //         btnHelp = menu.Text("ℹ Help")
//         // )
//         // menu.Reply(
//         //         menu.Row(btnHelp),
//         // )
//         // b.Handle(&amp;btnHelp, func(m *tb.Message) {
//         //         b.Send(m.Chat, "Тута будет помощь.")
//         // })
//         // b.Handle("/help", func(m *tb.Message) {
//         //         // b.Send(m.Chat, "test", menu)
//         // })
//         b.Send(&amp;teleAdminUser, "Запуск - "+time.Now().Format(time.ANSIC))
//         b.Start()
// }
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
